# 5 Файл - Электронный портфолио студента-исследователя

---
# Python
---

```python
# portfolio_app
## Главный файл приложения, Конфигурация (подключение к БД, пути), Модуль работы с базой данных, Модуль графического интерфейса и т.к.
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Электронный портфолио студента-исследователя
Экспорт в Excel и Word в указанную папку
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import sqlite3
from pathlib import Path
import os
import re
import subprocess
import platform
from datetime import datetime
import openpyxl
from openpyxl import Workbook
from openpyxl.chart import BarChart, Reference
from openpyxl.styles import Font, Alignment
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

# ==================== КОНФИГУРАЦИЯ ПУТЕЙ ====================
# ВАЖНО: Укажите правильный путь для экспорта файлов
# Используем сырую строку (raw string) для Windows путей
EXPORT_PATH = r"C:\Users\Student\Desktop\21Is\Проект5"

class Config:
    ENTRY_TYPES = ['Публикация', 'Конференция', 'Грант', 'Преподавание', 'Достижение']
    DB_FILE = "portfolio.db"
    
    # Папки для хранения данных (текущая директория)
    DATA_DIR = "данные_портфолио"
    MARKDOWN_DIR = os.path.join(DATA_DIR, "markdown_файлы")
    
    # Папка для экспорта (ваша указанная папка)
    EXPORT_DIR = EXPORT_PATH

# ==================== ПРОВЕРКА И СОЗДАНИЕ ПАПОК ====================
def setup_directories():
    """Создание необходимых папок"""
    directories = [
        Config.DATA_DIR,
        Config.MARKDOWN_DIR,
        Config.EXPORT_DIR  # Основная папка для экспорта
    ]
    
    for directory in directories:
        try:
            os.makedirs(directory, exist_ok=True)
            print(f"Папка создана/проверена: {directory}")
        except Exception as e:
            print(f"Ошибка создания папки {directory}: {e}")

# ==================== БАЗА ДАННЫХ SQLite ====================
class DatabaseConnection:
    def __init__(self):
        self.connection = None
        self.db_file = os.path.join(Config.DATA_DIR, Config.DB_FILE)
    
    def connect(self):
        try:
            self.connection = sqlite3.connect(self.db_file)
            self.connection.row_factory = sqlite3.Row
            print(f"Подключение к БД: {self.db_file}")
            self.create_tables()
            return True
        except Exception as e:
            print(f"Ошибка подключения к БД: {e}")
            messagebox.showerror("Ошибка", f"Не удалось подключиться к базе данных: {e}")
            return False
    
    def create_tables(self):
        """Создание таблиц в базе данных"""
        try:
            cursor = self.connection.cursor()
            
            # Таблица записей
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS entries (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    entry_type TEXT NOT NULL,
                    file_path TEXT,
                    year INTEGER NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # Таблица соавторов
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS coauthors (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL UNIQUE
                )
            ''')
            
            # Таблица связи записей и соавторов
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS entry_coauthors (
                    entry_id INTEGER,
                    coauthor_id INTEGER,
                    FOREIGN KEY (entry_id) REFERENCES entries(id) ON DELETE CASCADE,
                    FOREIGN KEY (coauthor_id) REFERENCES coauthors(id) ON DELETE CASCADE,
                    PRIMARY KEY (entry_id, coauthor_id)
                )
            ''')
            
            # Таблица лога активности
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS activity_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    entry_id INTEGER,
                    event_type TEXT NOT NULL,
                    event_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (entry_id) REFERENCES entries(id) ON DELETE CASCADE
                )
            ''')
            
            self.connection.commit()
            print("Таблицы базы данных созданы/проверены")
            
        except Exception as e:
            print(f"Ошибка создания таблиц: {e}")
    
    def execute_query(self, query, params=None, fetch=False):
        try:
            cursor = self.connection.cursor()
            cursor.execute(query, params or ())
            
            if fetch:
                result = cursor.fetchall()
                return result
            else:
                self.connection.commit()
                return True
        except Exception as e:
            print(f"Ошибка SQL: {e}")
            return False
    
    def execute_query_one(self, query, params=None):
        try:
            cursor = self.connection.cursor()
            cursor.execute(query, params or ())
            result = cursor.fetchone()
            return result
        except Exception as e:
            print(f"Ошибка SQL: {e}")
            return None
    
    def get_lastrowid(self):
        """Получение ID последней вставленной записи"""
        cursor = self.connection.cursor()
        cursor.execute("SELECT last_insert_rowid()")
        result = cursor.fetchone()
        return result[0] if result else None

# ==================== РАБОТА С MARKDOWN ФАЙЛАМИ ====================
class MarkdownHandler:
    def __init__(self):
        self.base_path = Config.MARKDOWN_DIR
    
    def sanitize_filename(self, title):
        """Очистка имени файла"""
        sanitized = re.sub(r'[<>:"/\\|?*]', '_', title)
        sanitized = re.sub(r'\s+', ' ', sanitized).strip()
        return sanitized[:100]
    
    def create_markdown_file(self, entry_id, title, content=""):
        """Создание файла Markdown"""
        sanitized_title = self.sanitize_filename(title)
        filename = f"{entry_id:03d}_{sanitized_title}.md"
        filepath = os.path.join(self.base_path, filename)
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"Создан файл: {filepath}")
            return filepath
        except Exception as e:
            print(f"Ошибка создания файла: {e}")
            return None
    
    def update_markdown_file(self, filepath, content):
        """Обновление файла Markdown"""
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            return True
        except Exception as e:
            print(f"Ошибка обновления файла: {e}")
            return False
    
    def read_markdown_file(self, filepath):
        """Чтение файла Markdown"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return f.read()
        except Exception as e:
            print(f"Ошибка чтения файла: {e}")
            return ""
    
    def open_in_external_editor(self, filepath):
        """Открытие файла во внешнем редакторе"""
        try:
            if platform.system() == "Windows":
                os.startfile(filepath)
            elif platform.system() == "Darwin":
                subprocess.run(["open", filepath])
            else:
                subprocess.run(["xdg-open", filepath])
            return True
        except Exception as e:
            print(f"Ошибка открытия файла: {e}")
            return False

# ==================== ЭКСПОРТ В EXCEL ====================
class ExcelExporter:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def collect_statistics(self):
        """Сбор статистики для отчёта"""
        stats = {}
        
        try:
            # Общее количество записей
            total_query = "SELECT COUNT(*) FROM entries"
            total_result = self.db.execute_query_one(total_query)
            stats['total_entries'] = total_result[0] if total_result else 0
            
            # Распределение по типам
            type_query = "SELECT entry_type, COUNT(*) FROM entries GROUP BY entry_type ORDER BY COUNT(*) DESC"
            stats['by_type'] = self.db.execute_query(type_query, fetch=True) or []
            
            # Распределение по годам
            year_query = "SELECT year, COUNT(*) FROM entries GROUP BY year ORDER BY year"
            stats['by_year'] = self.db.execute_query(year_query, fetch=True) or []
            
            # Количество уникальных соавторов
            coauthor_query = "SELECT COUNT(DISTINCT coauthor_id) FROM entry_coauthors"
            coauthor_result = self.db.execute_query_one(coauthor_query)
            stats['unique_coauthors'] = coauthor_result[0] if coauthor_result else 0
            
            # Последние 5 записей
            recent_query = "SELECT title, entry_type, year FROM entries ORDER BY created_at DESC LIMIT 5"
            stats['recent_entries'] = self.db.execute_query(recent_query, fetch=True) or []
            
        except Exception as e:
            print(f"Ошибка сбора статистики: {e}")
        
        return stats
    
    def generate_excel_report(self, filename=None):
        """Генерация Excel отчёта"""
        try:
            # Если имя файла не указано, создаём автоматически
            if not filename:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = os.path.join(Config.EXPORT_DIR, f"портфолио_отчет_{timestamp}.xlsx")
            
            # Создаём рабочую книгу
            wb = Workbook()
            ws = wb.active
            ws.title = "Статистика портфолио"
            
            # Собираем статистику
            stats = self.collect_statistics()
            
            # Заголовок
            ws['A1'] = "Отчёт по портфолио исследователя"
            ws['A1'].font = Font(size=16, bold=True)
            ws.merge_cells('A1:E1')
            
            ws['A2'] = f"Дата формирования: {datetime.now().strftime('%d.%m.%Y %H:%M')}"
            ws.merge_cells('A2:E2')
            
            # Общая статистика
            ws['A4'] = "ОБЩАЯ СТАТИСТИКА"
            ws['A4'].font = Font(size=14, bold=True)
            ws.merge_cells('A4:E4')
            
            row = 5
            ws.cell(row=row, column=1, value="Всего записей в портфолио:")
            ws.cell(row=row, column=2, value=stats['total_entries'])
            row += 1
            
            ws.cell(row=row, column=1, value="Уникальных соавторов:")
            ws.cell(row=row, column=2, value=stats['unique_coauthors'])
            row += 2
            
            # Распределение по типам
            ws.cell(row=row, column=1, value="РАСПРЕДЕЛЕНИЕ ПО ТИПАМ")
            ws.cell(row=row, column=1).font = Font(size=14, bold=True)
            ws.merge_cells(f'A{row}:E{row}')
            row += 1
            
            ws.cell(row=row, column=1, value="Тип записи")
            ws.cell(row=row, column=2, value="Количество")
            row += 1
            
            for entry_type, count in stats['by_type']:
                ws.cell(row=row, column=1, value=entry_type)
                ws.cell(row=row, column=2, value=count)
                row += 1
            
            row += 1
            
            # Распределение по годам
            ws.cell(row=row, column=1, value="РАСПРЕДЕЛЕНИЕ ПО ГОДАМ")
            ws.cell(row=row, column=1).font = Font(size=14, bold=True)
            ws.merge_cells(f'A{row}:E{row}')
            row += 1
            
            ws.cell(row=row, column=1, value="Год")
            ws.cell(row=row, column=2, value="Количество")
            row += 1
            
            for year, count in stats['by_year']:
                ws.cell(row=row, column=1, value=year)
                ws.cell(row=row, column=2, value=count)
                row += 1
            
            # Создаём лист с графиком
            if stats['by_type']:
                ws_chart = wb.create_sheet("Графики")
                
                # Копируем данные для графика
                start_row = 1
                ws_chart.cell(row=start_row, column=1, value="Тип записи")
                ws_chart.cell(row=start_row, column=2, value="Количество")
                
                for i, (entry_type, count) in enumerate(stats['by_type'], start=2):
                    ws_chart.cell(row=i, column=1, value=entry_type)
                    ws_chart.cell(row=i, column=2, value=count)
                
                # Создаём график
                chart = BarChart()
                chart.title = "Распределение записей по типам"
                chart.style = 10
                
                data = Reference(ws_chart, min_col=2, min_row=1, max_row=len(stats['by_type']) + 1)
                categories = Reference(ws_chart, min_col=1, min_row=2, max_row=len(stats['by_type']) + 1)
                
                chart.add_data(data, titles_from_data=True)
                chart.set_categories(categories)
                chart.x_axis.title = "Тип записи"
                chart.y_axis.title = "Количество"
                
                ws_chart.add_chart(chart, "D2")
            
            # Сохраняем файл
            wb.save(filename)
            print(f"Excel отчёт сохранён: {filename}")
            return filename
            
        except Exception as e:
            print(f"Ошибка создания Excel отчёта: {e}")
            return None

# ==================== ЭКСПОРТ В WORD ====================
class WordExporter:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def generate_word_report(self, filename=None):
        """Генерация Word отчёта"""
        try:
            # Если имя файла не указано, создаём автоматически
            if not filename:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = os.path.join(Config.EXPORT_DIR, f"портфолио_отчет_{timestamp}.docx")
            
            # Создаём документ
            doc = Document()
            
            # Настройка стилей
            style = doc.styles['Normal']
            style.font.name = 'Times New Roman'
            style.font.size = Pt(12)
            
            # Титульная страница
            title = doc.add_heading('ЭЛЕКТРОННОЕ ПОРТФОЛИО\nСТУДЕНТА-ИССЛЕДОВАТЕЛЯ', 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Пустые строки
            for _ in range(6):
                doc.add_paragraph()
            
            # Дата
            date_para = doc.add_paragraph()
            date_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
            date_run = date_para.add_run(f"Дата формирования отчёта: {datetime.now().strftime('%d.%m.%Y')}")
            
            # Новая страница
            doc.add_page_break()
            
            # Заголовок отчёта
            doc.add_heading('АНАЛИТИЧЕСКИЙ ОТЧЁТ', 1)
            
            # Собираем статистику
            stats = self.collect_statistics()
            
            # Общая статистика
            doc.add_heading('1. Общая статистика', 2)
            
            table = doc.add_table(rows=1, cols=2)
            table.style = 'LightShading'
            
            # Заголовки таблицы
            hdr_cells = table.rows[0].cells
            hdr_cells[0].text = 'Показатель'
            hdr_cells[1].text = 'Значение'
            
            # Данные
            data_rows = [
                ('Всего записей в портфолио', stats.get('total_entries', 0)),
                ('Уникальных соавторов', stats.get('unique_coauthors', 0)),
            ]
            
            for row_data in data_rows:
                row_cells = table.add_row().cells
                row_cells[0].text = str(row_data[0])
                row_cells[1].text = str(row_data[1])
            
            # Распределение по типам
            if stats.get('by_type'):
                doc.add_heading('2. Распределение записей по типам', 2)
                
                type_table = doc.add_table(rows=1, cols=2)
                type_table.style = 'LightShading'
                
                type_hdr = type_table.rows[0].cells
                type_hdr[0].text = 'Тип записи'
                type_hdr[1].text = 'Количество'
                
                for entry_type, count in stats['by_type']:
                    row_cells = type_table.add_row().cells
                    row_cells[0].text = str(entry_type)
                    row_cells[1].text = str(count)
            
            # Распределение по годам
            if stats.get('by_year'):
                doc.add_heading('3. Распределение записей по годам', 2)
                
                year_table = doc.add_table(rows=1, cols=2)
                year_table.style = 'LightShading'
                
                year_hdr = year_table.rows[0].cells
                year_hdr[0].text = 'Год'
                year_hdr[1].text = 'Количество'
                
                for year, count in stats['by_year']:
                    row_cells = year_table.add_row().cells
                    row_cells[0].text = str(year)
                    row_cells[1].text = str(count)
            
            # Последние записи
            if stats.get('recent_entries'):
                doc.add_heading('4. Последние добавленные записи', 2)
                
                for i, (title, entry_type, year) in enumerate(stats['recent_entries'], 1):
                    p = doc.add_paragraph()
                    p.add_run(f"{i}. ").bold = True
                    p.add_run(f"{title} ({entry_type}, {year} год)")
            
            # Сохраняем документ
            doc.save(filename)
            print(f"Word отчёт сохранён: {filename}")
            return filename
            
        except Exception as e:
            print(f"Ошибка создания Word отчёта: {e}")
            return None
    
    def collect_statistics(self):
        """Сбор статистики (такой же метод как в ExcelExporter)"""
        stats = {}
        
        try:
            total_query = "SELECT COUNT(*) FROM entries"
            total_result = self.db.execute_query_one(total_query)
            stats['total_entries'] = total_result[0] if total_result else 0
            
            type_query = "SELECT entry_type, COUNT(*) FROM entries GROUP BY entry_type ORDER BY COUNT(*) DESC"
            stats['by_type'] = self.db.execute_query(type_query, fetch=True) or []
            
            year_query = "SELECT year, COUNT(*) FROM entries GROUP BY year ORDER BY year"
            stats['by_year'] = self.db.execute_query(year_query, fetch=True) or []
            
            coauthor_query = "SELECT COUNT(DISTINCT coauthor_id) FROM entry_coauthors"
            coauthor_result = self.db.execute_query_one(coauthor_query)
            stats['unique_coauthors'] = coauthor_result[0] if coauthor_result else 0
            
            recent_query = "SELECT title, entry_type, year FROM entries ORDER BY created_at DESC LIMIT 5"
            stats['recent_entries'] = self.db.execute_query(recent_query, fetch=True) or []
            
        except Exception as e:
            print(f"Ошибка сбора статистики: {e}")
        
        return stats

# ==================== ГЛАВНОЕ ОКНО ПРИЛОЖЕНИЯ ====================
class PortfolioApp:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Электронный портфолио студента-исследователя")
        self.root.geometry("1200x700")
        
        # Настройка путей
        setup_directories()
        
        # Инициализация компонентов
        self.db = DatabaseConnection()
        self.md_handler = MarkdownHandler()
        self.excel_exporter = ExcelExporter(self.db)
        self.word_exporter = WordExporter(self.db)
        
        # Текущая выбранная запись
        self.current_entry_id = None
        
        # Создание интерфейса
        self.create_widgets()
        
        # Подключение к БД
        if not self.db.connect():
            messagebox.showwarning("Внимание", "Приложение запущено в ограниченном режиме")
        
        # Загрузка данных
        self.load_entries()
    
    def create_widgets(self):
        """Создание интерфейса"""
        # Основной контейнер
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # 1. Панель управления
        control_frame = ttk.LabelFrame(main_frame, text="Управление записью", padding="10")
        control_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        control_frame.columnconfigure(1, weight=1)
        
        # Название
        ttk.Label(control_frame, text="Название:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
        self.title_entry = ttk.Entry(control_frame, width=50)
        self.title_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 10))
        
        # Тип
        ttk.Label(control_frame, text="Тип:").grid(row=0, column=2, sticky=tk.W, padx=(0, 5))
        self.type_combobox = ttk.Combobox(control_frame, values=Config.ENTRY_TYPES, state='readonly', width=15)
        self.type_combobox.grid(row=0, column=3, sticky=tk.W, padx=(0, 10))
        self.type_combobox.current(0)
        
        # Год
        ttk.Label(control_frame, text="Год:").grid(row=0, column=4, sticky=tk.W, padx=(0, 5))
        self.year_spinbox = ttk.Spinbox(control_frame, from_=2000, to=2100, width=8)
        self.year_spinbox.delete(0, tk.END)
        self.year_spinbox.insert(0, str(datetime.now().year))
        self.year_spinbox.grid(row=0, column=5, sticky=tk.W)
        
        # Кнопки управления
        button_frame = ttk.Frame(control_frame)
        button_frame.grid(row=1, column=0, columnspan=6, pady=(10, 0), sticky=(tk.W, tk.E))
        
        self.create_btn = ttk.Button(button_frame, text="Создать", command=self.create_entry)
        self.create_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        self.save_btn = ttk.Button(button_frame, text="Сохранить", command=self.save_entry, state=tk.DISABLED)
        self.save_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        self.delete_btn = ttk.Button(button_frame, text="Удалить", command=self.delete_entry, state=tk.DISABLED)
        self.delete_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        self.open_btn = ttk.Button(button_frame, text="Открыть описание", command=self.open_description, state=tk.DISABLED)
        self.open_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        # Кнопки экспорта
        self.excel_btn = ttk.Button(button_frame, text="Экспорт в Excel", command=self.export_to_excel)
        self.excel_btn.pack(side=tk.LEFT, padx=(0, 5))
        
        self.word_btn = ttk.Button(button_frame, text="Экспорт в Word", command=self.export_to_word)
        self.word_btn.pack(side=tk.LEFT)
        
        # 2. Основная область
        content_frame = ttk.Frame(main_frame)
        content_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        content_frame.columnconfigure(0, weight=1)
        content_frame.columnconfigure(1, weight=2)
        content_frame.rowconfigure(0, weight=1)
        
        # Список записей
        list_frame = ttk.LabelFrame(content_frame, text="Список записей", padding="5")
        list_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)
        
        columns = ('Название', 'Тип', 'Год', 'Создано')
        self.treeview = ttk.Treeview(list_frame, columns=columns, show='headings', selectmode='browse')
        
        for col in columns:
            self.treeview.heading(col, text=col)
            self.treeview.column(col, width=150)
        
        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.treeview.yview)
        self.treeview.configure(yscrollcommand=scrollbar.set)
        
        self.treeview.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        self.treeview.bind('<<TreeviewSelect>>', self.on_entry_select)
        
        # Редактор
        editor_frame = ttk.LabelFrame(content_frame, text="Описание (Markdown)", padding="5")
        editor_frame.grid(row=0, column=1, sticky=(tk.W, tk.E, tk.N, tk.S))
        editor_frame.columnconfigure(0, weight=1)
        editor_frame.rowconfigure(0, weight=1)
        
        self.text_editor = scrolledtext.ScrolledText(editor_frame, wrap=tk.WORD, font=('Arial', 10))
        self.text_editor.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # 3. Панель соавторов
        coauthor_frame = ttk.LabelFrame(main_frame, text="Соавторы", padding="10")
        coauthor_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        ttk.Label(coauthor_frame, text="Добавить соавтора:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
        self.coauthor_entry = ttk.Entry(coauthor_frame, width=30)
        self.coauthor_entry.grid(row=0, column=1, sticky=tk.W, padx=(0, 5))
        
        self.add_coauthor_btn = ttk.Button(coauthor_frame, text="Добавить", command=self.add_coauthor, state=tk.DISABLED)
        self.add_coauthor_btn.grid(row=0, column=2, padx=(0, 10))
        
        ttk.Label(coauthor_frame, text="Текущие соавторы:").grid(row=1, column=0, sticky=tk.NW, padx=(0, 5), pady=(10, 0))
        
        self.coauthors_text = tk.Text(coauthor_frame, height=4, width=50, state=tk.DISABLED, 
                                      font=('Arial', 10), bg='#f9f9f9')
        self.coauthors_text.grid(row=1, column=1, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0), padx=(0, 5))
        
        # 4. Панель отчётов
        report_frame = ttk.LabelFrame(main_frame, text="Формирование отчётов", padding="15")
        report_frame.grid(row=3, column=0, sticky=(tk.W, tk.E))
        
        info_text = f"Отчёты будут сохранены в папку:\n{Config.EXPORT_DIR}\n\nExcel-отчёт содержит статистику и графики.\nWord-отчёт содержит аналитическую информацию."
        
        ttk.Label(report_frame, text=info_text, justify=tk.LEFT).pack(anchor=tk.W)
        
        self.report_btn = ttk.Button(report_frame, text="Сформировать оба отчёта", 
                                    command=self.generate_both_reports)
        self.report_btn.pack(pady=(10, 0))
    
    def load_entries(self):
        """Загрузка записей из БД"""
        for item in self.treeview.get_children():
            self.treeview.delete(item)
        
        try:
            query = """
                SELECT id, title, entry_type, year, 
                       strftime('%d.%m.%Y', created_at) as created_at
                FROM entries ORDER BY created_at DESC
            """
            entries = self.db.execute_query(query, fetch=True)
            
            if entries:
                for entry in entries:
                    self.treeview.insert('', 'end', values=entry[1:], iid=entry[0])
        except Exception as e:
            print(f"Ошибка загрузки: {e}")
    
    def create_entry(self):
        """Создание новой записи"""
        title = self.title_entry.get().strip()
        entry_type = self.type_combobox.get()
        year_str = self.year_spinbox.get().strip()
        
        if not title:
            messagebox.showwarning("Ошибка", "Введите название записи")
            return
        
        try:
            year = int(year_str)
        except ValueError:
            messagebox.showwarning("Ошибка", "Введите корректный год")
            return
        
        try:
            # Создаём запись в БД
            query = "INSERT INTO entries (title, entry_type, file_path, year) VALUES (?, ?, ?, ?)"
            if self.db.execute_query(query, (title, entry_type, '', year)):
                # Получаем ID новой записи
                entry_id = self.db.get_lastrowid()
                
                if entry_id:
                    # Создаём файл
                    filepath = self.md_handler.create_markdown_file(entry_id, title)
                    
                    if filepath:
                        # Обновляем путь в БД
                        update_query = "UPDATE entries SET file_path = ? WHERE id = ?"
                        self.db.execute_query(update_query, (filepath, entry_id))
                        
                        # Логируем
                        log_query = "INSERT INTO activity_log (entry_id, event_type) VALUES (?, ?)"
                        self.db.execute_query(log_query, (entry_id, 'CREATE'))
                        
                        # Обновляем интерфейс
                        self.load_entries()
                        self.clear_fields()
                        
                        messagebox.showinfo("Успех", "Запись создана")
                    else:
                        messagebox.showerror("Ошибка", "Не удалось создать файл")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка создания: {e}")
    
    def on_entry_select(self, event):
        """Обработка выбора записи"""
        selection = self.treeview.selection()
        
        if selection:
            entry_id = selection[0]
            self.current_entry_id = entry_id
            
            # Активируем кнопки
            self.save_btn.config(state=tk.NORMAL)
            self.delete_btn.config(state=tk.DISABLED)
            self.open_btn.config(state=tk.DISABLED)
            self.add_coauthor_btn.config(state=tk.DISABLED)
            
            try:
                # Загружаем данные записи
                query = "SELECT title, entry_type, year, file_path FROM entries WHERE id = ?"
                result = self.db.execute_query_one(query, (entry_id,))
                
                if result:
                    self.title_entry.delete(0, tk.END)
                    self.title_entry.insert(0, result['title'])
                    self.type_combobox.set(result['entry_type'])
                    self.year_spinbox.delete(0, tk.END)
                    self.year_spinbox.insert(0, str(result['year']))
                    
                    # Загружаем содержимое файла
                    if result['file_path']:
                        content = self.md_handler.read_markdown_file(result['file_path'])
                        self.text_editor.delete(1.0, tk.END)
                        self.text_editor.insert(1.0, content)
                    
                    # Загружаем соавторов
                    self.load_coauthors(entry_id)
                    
                    # Логируем просмотр
                    log_query = "INSERT INTO activity_log (entry_id, event_type) VALUES (?, ?)"
                    self.db.execute_query(log_query, (entry_id, 'VIEW'))
                    
                    # Активируем кнопки после загрузки
                    self.save_btn.config(state=tk.NORMAL)
                    self.delete_btn.config(state=tk.NORMAL)
                    self.open_btn.config(state=tk.NORMAL)
                    self.add_coauthor_btn.config(state=tk.NORMAL)
            except Exception as e:
                print(f"Ошибка загрузки: {e}")
    
    def save_entry(self):
        """Сохранение изменений"""
        if not self.current_entry_id:
            return
        
        title = self.title_entry.get().strip()
        entry_type = self.type_combobox.get()
        year_str = self.year_spinbox.get().strip()
        content = self.text_editor.get(1.0, tk.END).strip()
        
        if not title:
            messagebox.showwarning("Ошибка", "Введите название записи")
            return
        
        try:
            year = int(year_str)
        except ValueError:
            messagebox.showwarning("Ошибка", "Введите корректный год")
            return
        
        try:
            # Обновляем запись в БД
            update_query = "UPDATE entries SET title = ?, entry_type = ?, year = ? WHERE id = ?"
            if self.db.execute_query(update_query, (title, entry_type, year, self.current_entry_id)):
                # Получаем путь к файлу
                file_query = "SELECT file_path FROM entries WHERE id = ?"
                result = self.db.execute_query_one(file_query, (self.current_entry_id,))
                
                if result and result['file_path']:
                    # Обновляем файл
                    if self.md_handler.update_markdown_file(result['file_path'], content):
                        # Логируем
                        log_query = "INSERT INTO activity_log (entry_id, event_type) VALUES (?, ?)"
                        self.db.execute_query(log_query, (self.current_entry_id, 'UPDATE'))
                        
                        # Обновляем список
                        self.load_entries()
                        messagebox.showinfo("Успех", "Изменения сохранены")
                    else:
                        messagebox.showerror("Ошибка", "Не удалось сохранить файл")
                else:
                    # Если файла нет, создаём его
                    filepath = self.md_handler.create_markdown_file(self.current_entry_id, title, content)
                    if filepath:
                        update_file_query = "UPDATE entries SET file_path = ? WHERE id = ?"
                        self.db.execute_query(update_file_query, (filepath, self.current_entry_id))
                        messagebox.showinfo("Успех", "Изменения сохранены, файл создан")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка сохранения: {e}")
    
    def delete_entry(self):
        """Удаление записи"""
        if not self.current_entry_id:
            return
        
        if not messagebox.askyesno("Подтверждение", "Удалить выбранную запись?"):
            return
        
        try:
            # Получаем путь к файлу
            file_query = "SELECT file_path FROM entries WHERE id = ?"
            result = self.db.execute_query_one(file_query, (self.current_entry_id,))
            
            # Удаляем из БД
            delete_query = "DELETE FROM entries WHERE id = ?"
            if self.db.execute_query(delete_query, (self.current_entry_id,)):
                # Удаляем файл
                if result and result['file_path'] and os.path.exists(result['file_path']):
                    try:
                        os.remove(result['file_path'])
                    except:
                        pass
                
                # Сбрасываем интерфейс
                self.current_entry_id = None
                self.clear_fields()
                self.save_btn.config(state=tk.DISABLED)
                self.delete_btn.config(state=tk.DISABLED)
                self.open_btn.config(state=tk.DISABLED)
                self.add_coauthor_btn.config(state=tk.DISABLED)
                
                # Обновляем список
                self.load_entries()
                messagebox.showinfo("Успех", "Запись удалена")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка удаления: {e}")
    
    def add_coauthor(self):
        """Добавление соавтора"""
        if not self.current_entry_id:
            return
        
        coauthor_name = self.coauthor_entry.get().strip()
        
        if not coauthor_name:
            messagebox.showwarning("Ошибка", "Введите имя соавтора")
            return
        
        try:
            # Добавляем соавтора
            add_query = "INSERT OR IGNORE INTO coauthors (name) VALUES (?)"
            self.db.execute_query(add_query, (coauthor_name,))
            
            # Получаем ID соавтора
            id_query = "SELECT id FROM coauthors WHERE name = ?"
            result = self.db.execute_query_one(id_query, (coauthor_name,))
            
            if result:
                # Связываем с записью
                link_query = "INSERT OR IGNORE INTO entry_coauthors (entry_id, coauthor_id) VALUES (?, ?)"
                self.db.execute_query(link_query, (self.current_entry_id, result['id']))
                
                # Обновляем список соавторов
                self.load_coauthors(self.current_entry_id)
                self.coauthor_entry.delete(0, tk.END)
                messagebox.showinfo("Успех", "Соавтор добавлен")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка добавления: {e}")
    
    def load_coauthors(self, entry_id):
        """Загрузка соавторов записи"""
        self.coauthors_text.config(state=tk.NORMAL)
        self.coauthors_text.delete(1.0, tk.END)
        
        try:
            query = """
                SELECT c.name 
                FROM coauthors c
                JOIN entry_coauthors ec ON c.id = ec.coauthor_id
                WHERE ec.entry_id = ?
            """
            coauthors = self.db.execute_query(query, (entry_id,), fetch=True)
            
            if coauthors:
                coauthor_list = "\n".join([c['name'] for c in coauthors])
                self.coauthors_text.insert(1.0, coauthor_list)
        except Exception as e:
            print(f"Ошибка загрузки соавторов: {e}")
        
        self.coauthors_text.config(state=tk.DISABLED)
    
    def open_description(self):
        """Открытие файла описания"""
        if not self.current_entry_id:
            return
        
        try:
            query = "SELECT file_path FROM entries WHERE id = ?"
            result = self.db.execute_query_one(query, (self.current_entry_id,))
            
            if result and result['file_path'] and os.path.exists(result['file_path']):
                self.md_handler.open_in_external_editor(result['file_path'])
            else:
                messagebox.showwarning("Ошибка", "Файл не найден")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка открытия: {e}")
    
    def export_to_excel(self):
        """Экспорт в Excel"""
        try:
            # Проверяем, есть ли записи
            count_query = "SELECT COUNT(*) FROM entries"
            result = self.db.execute_query_one(count_query)
            
            if not result or result[0] == 0:
                messagebox.showwarning("Внимание", "Нет данных для экспорта. Сначала создайте записи.")
                return
            
            # Генерируем Excel отчёт
            excel_file = self.excel_exporter.generate_excel_report()
            
            if excel_file:
                messagebox.showinfo("Успех", 
                    f"Excel отчёт сохранён:\n{excel_file}")
            else:
                messagebox.showerror("Ошибка", "Не удалось создать Excel отчёт")
                
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка экспорта в Excel: {e}")
    
    def export_to_word(self):
        """Экспорт в Word"""
        try:
            # Проверяем, есть ли записи
            count_query = "SELECT COUNT(*) FROM entries"
            result = self.db.execute_query_one(count_query)
            
            if not result or result[0] == 0:
                messagebox.showwarning("Внимание", "Нет данных для экспорта. Сначала создайте записи.")
                return
            
            # Генерируем Word отчёт
            word_file = self.word_exporter.generate_word_report()
            
            if word_file:
                messagebox.showinfo("Успех", 
                    f"Word отчёт сохранён:\n{word_file}")
            else:
                messagebox.showerror("Ошибка", "Не удалось создать Word отчёт")
                
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка экспорта в Word: {e}")
    
    def generate_both_reports(self):
        """Создание обоих отчётов одновременно"""
        try:
            # Проверяем данные
            count_query = "SELECT COUNT(*) FROM entries"
            result = self.db.execute_query_one(count_query)
            
            if not result or result[0] == 0:
                messagebox.showwarning("Внимание", "Нет данных для отчётов. Сначала создайте записи.")
                return
            
            # Создаём Excel отчёт
            excel_file = self.excel_exporter.generate_excel_report()
            
            # Создаём Word отчёт
            word_file = self.word_exporter.generate_word_report()
            
            if excel_file and word_file:
                messagebox.showinfo("Успех", 
                    f"Оба отчёта успешно созданы!\n\n"
                    f"Excel: {os.path.basename(excel_file)}\n"
                    f"Word: {os.path.basename(word_file)}")
            else:
                messagebox.showwarning("Внимание", 
                    "Не все отчёты удалось создать.\n"
                    f"Excel: {'Создан' if excel_file else 'Не создан'}\n"
                    f"Word: {'Создан' if word_file else 'Не создан'}")
                
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка создания отчётов: {e}")
    
    def clear_fields(self):
        """Очистка полей ввода"""
        self.title_entry.delete(0, tk.END)
        self.type_combobox.current(0)
        self.year_spinbox.delete(0, tk.END)
        self.year_spinbox.insert(0, str(datetime.now().year))
        self.text_editor.delete(1.0, tk.END)
        
        self.coauthors_text.config(state=tk.NORMAL)
        self.coauthors_text.delete(1.0, tk.END)
        self.coauthors_text.config(state=tk.DISABLED)
        
        self.coauthor_entry.delete(0, tk.END)
    
    def run(self):
        """Запуск приложения"""
        self.root.mainloop()

# ==================== ЗАПУСК ПРИЛОЖЕНИЯ ====================
def main():
    """Точка входа"""
    try:
        # Создаём папки
        setup_directories()
        
        # Проверяем папку для экспорта
        if not os.path.exists(Config.EXPORT_DIR):
            print(f"ВНИМАНИЕ: Папка для экспорта не существует: {Config.EXPORT_DIR}")
            print("Попытка создать папку...")
            try:
                os.makedirs(Config.EXPORT_DIR, exist_ok=True)
                print(f"Папка создана: {Config.EXPORT_DIR}")
            except Exception as e:
                print(f"Не удалось создать папку: {e}")
                print("Отчёты будут сохраняться в текущую директорию")
                Config.EXPORT_DIR = "."
        
        # Запускаем приложение
        app = PortfolioApp()
        app.run()
        
    except Exception as e:
        messagebox.showerror("Критическая ошибка", f"Не удалось запустить приложение:\n{e}")

if __name__ == "__main__":
    main()

```

---
# Python
---

```sql
# schema
## 
-- Таблица записей портфолио
CREATE TABLE entries (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    entry_type VARCHAR(50) NOT NULL CHECK (entry_type IN 
        ('Публикация', 'Конференция', 'Грант', 'Преподавание', 'Достижение')),
    file_path VARCHAR(500) UNIQUE NOT NULL,
    year INTEGER NOT NULL CHECK (year >= 1900 AND year <= 2100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблица соавторов
CREATE TABLE coauthors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE
);

-- Таблица связи записей и соавторов (многие-ко-многим)
CREATE TABLE entry_coauthors (
    entry_id INTEGER REFERENCES entries(id) ON DELETE CASCADE,
    coauthor_id INTEGER REFERENCES coauthors(id) ON DELETE CASCADE,
    PRIMARY KEY (entry_id, coauthor_id)
);

-- Таблица лога активности
CREATE TABLE activity_log (
    id SERIAL PRIMARY KEY,
    entry_id INTEGER REFERENCES entries(id) ON DELETE CASCADE,
    event_type VARCHAR(10) NOT NULL CHECK (event_type IN ('CREATE', 'UPDATE', 'VIEW')),
    event_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Триггер для автоматического обновления updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_entries_updated_at 
    BEFORE UPDATE ON entries 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Создание индексов для ускорения поиска
CREATE INDEX idx_entries_type ON entries(entry_type);
CREATE INDEX idx_entries_year ON entries(year);
CREATE INDEX idx_activity_log_time ON activity_log(event_time);

```

---
# Python
---
